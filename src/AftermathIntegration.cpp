#if RGL_AFTERMATH_AVAILABLE
#include <d3d12.h>
#include <GFSDK_Aftermath.h>
#include <GFSDK_Aftermath_GpuCrashDump.h>
#include <GFSDK_Aftermath_GpuCrashDumpDecoding.h>
#include "AftermathIntegration.hpp"
#include <filesystem>
#include <format>
#include <fstream>
#include <unordered_map>

// In addition to RGL library copyright:
//*********************************************************
//
// Copyright (c) 2019-2022, NVIDIA CORPORATION. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//*********************************************************


bool operator==(const GFSDK_Aftermath_ShaderDebugInfoIdentifier& a, const GFSDK_Aftermath_ShaderDebugInfoIdentifier& b) {
    return a.id[0] == b.id[0] && a.id[1] == b.id[1];
}

bool operator==(const GFSDK_Aftermath_ShaderDebugName& a, const GFSDK_Aftermath_ShaderDebugName& b) {
    return std::string_view(a.name, sizeof(GFSDK_Aftermath_ShaderDebugName::name)) == std::string_view(b.name, sizeof(GFSDK_Aftermath_ShaderDebugName::name));
}

bool operator==(const GFSDK_Aftermath_ShaderBinaryHash& a, const GFSDK_Aftermath_ShaderBinaryHash& b) {
    return a.hash == b.hash;
}

namespace std {

    template<>
    struct hash<const GFSDK_Aftermath_ShaderBinaryHash>{
        size_t operator()(const GFSDK_Aftermath_ShaderBinaryHash& hash) const{
            return hash.hash;
        }
    };

    template<>
    struct hash<const GFSDK_Aftermath_ShaderDebugName> {
        size_t operator()(const GFSDK_Aftermath_ShaderDebugName& debugName) const{
            return std::hash<std::string_view>{}({ debugName.name,sizeof(GFSDK_Aftermath_ShaderDebugName::name) });
        }
    };

    template<>
    struct hash<const GFSDK_Aftermath_ShaderDebugInfoIdentifier> {
        size_t operator()(const GFSDK_Aftermath_ShaderDebugInfoIdentifier& debugIdentifier) const{
            return debugIdentifier.id[0] ^ debugIdentifier.id[1];
        }
    };
}

namespace RGL {

    std::mutex m_mutex;

    void AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_Result result) {
        if (result != GFSDK_Aftermath_Result::GFSDK_Aftermath_Result_Success) {
            throw std::runtime_error(std::format("Aftermath failure: {}", (int)result));
        }
    }


    class ShaderDatabase
    {
    public:
        ShaderDatabase() {
            // Add shader binaries to database
            auto searchDir = std::filesystem::current_path();

            for (const auto& path : std::filesystem::directory_iterator(searchDir)) {
                if (path.path().extension() == ".cso") {
                    AddShaderBinary(path.path().c_str());
                }
                else if (path.path().extension() == ".pdb") {
                    AddSourceShaderDebugData(path.path(), path.path().filename());
                }
            }
        }
        ~ShaderDatabase() {}

        // Find a shader bytecode binary by shader hash.
        bool FindShaderBinary(const GFSDK_Aftermath_ShaderBinaryHash& shaderHash, std::vector<uint8_t>& shader) const {
            // Find shader binary data for the shader hash
            auto i_shader = m_shaderBinaries.find(shaderHash);
            if (i_shader == m_shaderBinaries.end())
            {
                // Nothing found.
                return false;
            }

            shader = i_shader->second;
            return true;
        }

        // Find a source shader debug info by shader debug name generated by the DXC compiler.
        bool FindSourceShaderDebugData(const GFSDK_Aftermath_ShaderDebugName& shaderDebugName, std::vector<uint8_t>& debugData) const {
            // Find shader debug data for the shader debug name.
            auto i_data = m_sourceShaderDebugData.find(shaderDebugName);
            if (i_data == m_sourceShaderDebugData.end())
            {
                // Nothing found.
                return false;
            }

            debugData = i_data->second;
            return true;
        }

    private:

        void AddShaderBinary(const std::filesystem::path& path) {
            // Read the shader bytecode from the file
            std::vector<uint8_t> data;
            if (!ReadFile(path, data))
            {
                return;
            }

            // Create shader hashes for the shader bytecode
            const D3D12_SHADER_BYTECODE shader{ data.data(), data.size() };
            GFSDK_Aftermath_ShaderBinaryHash shaderHash;
            AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GetShaderHash(
                GFSDK_Aftermath_Version_API,
                &shader,
                &shaderHash));

            // Store the data for shader instruction address mapping when decoding GPU crash dumps.
            // cf. FindShaderBinary()
            m_shaderBinaries[shaderHash].swap(data);
        }
        void AddSourceShaderDebugData(const std::filesystem::path& path, std::filesystem::path fileName) {
            // Read the shader debug data from the file
            std::vector<uint8_t> data;
            if (!ReadFile(path, data))
            {
                return;
            }

            // Populate shader debug name.
            // The shaders used in this sample are compiled with compiler-generated debug data
            // file names. That means the debug data file's name matches the corresponding
            // shader's DebugName.
            // If shaders are built with user-defined debug data file names, the shader database
            // must maintain a mapping between the shader DebugName (queried from the shader
            // binary with GFSDK_Aftermath_GetShaderDebugName()) and the name of the file
            // containing the corresponding debug data.
            // Please see the documentation of GFSDK_Aftermath_GpuCrashDump_GenerateJSON() for
            // additional information.
            GFSDK_Aftermath_ShaderDebugName debugName;
            strncpy_s(debugName.name, fileName.string().c_str(), sizeof(debugName.name) - 1);

            // Store the data for shader instruction address mapping when decoding GPU crash dumps.
            // cf. FindSourceShaderDebugData()
            m_sourceShaderDebugData[debugName].swap(data);
        }

        static bool ReadFile(const std::filesystem::path& path, std::vector<uint8_t>& data) {
            std::ifstream fs(path, std::ios::in | std::ios::binary);
            if (!fs)
            {
                return false;
            }

            fs.seekg(0, std::ios::end);
            data.resize(fs.tellg());
            fs.seekg(0, std::ios::beg);
            fs.read(reinterpret_cast<char*>(data.data()), data.size());
            fs.close();

            return true;
        }

        // List of shader binaries by ShaderBinaryHash.
        std::unordered_map<const GFSDK_Aftermath_ShaderBinaryHash, std::vector<uint8_t>> m_shaderBinaries;

        // List of available source shader debug information.
        std::unordered_map<const GFSDK_Aftermath_ShaderDebugName, std::vector<uint8_t>> m_sourceShaderDebugData;
    };

    static std::unordered_map<const GFSDK_Aftermath_ShaderDebugInfoIdentifier, std::vector<uint8_t>> m_shaderDebugInfo;
    static ShaderDatabase m_shaderDatabase;

    void AftermathShaderDebugInfoLookupCallback(const GFSDK_Aftermath_ShaderDebugInfoIdentifier* pIdentifier,
        PFN_GFSDK_Aftermath_SetData setShaderDebugInfo,
        void* pUserData) {

        // Search the list of shader debug information blobs received earlier.
        auto i_debugInfo = m_shaderDebugInfo.find(*pIdentifier);
        if (i_debugInfo == m_shaderDebugInfo.end())
        {
            // Early exit, nothing found. No need to call setShaderDebugInfo.
            return;
        }

        // Let the GPU crash dump decoder know about the shader debug information
        // that was found.
        setShaderDebugInfo(i_debugInfo->second.data(), uint32_t(i_debugInfo->second.size()));
    }

    void AftermathShaderLookupCallback(
        const GFSDK_Aftermath_ShaderBinaryHash* pShaderHash,
        PFN_GFSDK_Aftermath_SetData setShaderBinary,
        void* pUserData)
    {
        // Find shader binary data for the shader hash in the shader database.
        std::vector<uint8_t> shaderBinary;
        if (!m_shaderDatabase.FindShaderBinary(*pShaderHash, shaderBinary))
        {
            // Early exit, nothing found. No need to call setShaderBinary.
            return;
        }

        // Let the GPU crash dump decoder know about the shader data
        // that was found.
        setShaderBinary(shaderBinary.data(), uint32_t(shaderBinary.size()));
    }

    void AftermathShaderSourceDebugInfoLookupCallback(
        const GFSDK_Aftermath_ShaderDebugName* pShaderDebugName,
        PFN_GFSDK_Aftermath_SetData setShaderBinary,
        void* pUserData)
    {
        // Find source debug info for the shader DebugName in the shader database.
        std::vector<uint8_t> sourceDebugInfo;
        if (!m_shaderDatabase.FindSourceShaderDebugData(*pShaderDebugName, sourceDebugInfo))
        {
            // Early exit, nothing found. No need to call setShaderBinary.
            return;
        }

        // Let the GPU crash dump decoder know about the shader debug data that was
        // found.
        setShaderBinary(sourceDebugInfo.data(), uint32_t(sourceDebugInfo.size()));
    }

    void WriteShaderDebugInformationToFile(
        GFSDK_Aftermath_ShaderDebugInfoIdentifier identifier,
        const void* pShaderDebugInfo,
        const uint32_t shaderDebugInfoSize)
    {
        // Create a unique file name.
        const std::string filePath = "shader-" + std::to_string(identifier.id[0]) + std::to_string(identifier.id[1]) + ".nvdbg";

        std::ofstream f(filePath, std::ios::out | std::ios::binary);
        if (f)
        {
            f.write((const char*)pShaderDebugInfo, shaderDebugInfoSize);
        }
    }

    void AftermathShaderDebugInfoCallback(const void* pShaderDebugInfo, const uint32_t shaderDebugInfoSize, void* pUserData) {
        // Make sure only one thread at a time...
        std::lock_guard<std::mutex> lock(m_mutex);

        // Get shader debug information identifier
        GFSDK_Aftermath_ShaderDebugInfoIdentifier identifier = {};
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GetShaderDebugInfoIdentifier(
            GFSDK_Aftermath_Version_API,
            pShaderDebugInfo,
            shaderDebugInfoSize,
            &identifier));

        // Store information for decoding of GPU crash dumps with shader address mapping
        // from within the application.
        std::vector<uint8_t> data((uint8_t*)pShaderDebugInfo, (uint8_t*)pShaderDebugInfo + shaderDebugInfoSize);
        m_shaderDebugInfo[identifier].swap(data);

        // Write to file for later in-depth analysis of crash dumps with Nsight Graphics
        WriteShaderDebugInformationToFile(identifier, pShaderDebugInfo, shaderDebugInfoSize);
    }

    void AftermathCrashDumpDescriptionCallback(PFN_GFSDK_Aftermath_AddGpuCrashDumpDescription addValue, void* pUserData) {
        addValue(0, "RGL Aftermath crash dump");    //TODO: add more data
    }

	void AftermathCrashDumpCallback(const void* pGpuCrashDump, const uint32_t gpuCrashDumpSize, void* pUserData) {
        // Create a GPU crash dump decoder object for the GPU crash dump.
        GFSDK_Aftermath_GpuCrashDump_Decoder decoder = {};
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GpuCrashDump_CreateDecoder(
            GFSDK_Aftermath_Version_API,
            pGpuCrashDump,
            gpuCrashDumpSize,
            &decoder));

        // Use the decoder object to read basic information, like application
        // name, PID, etc. from the GPU crash dump.
        GFSDK_Aftermath_GpuCrashDump_BaseInfo baseInfo = {};
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GpuCrashDump_GetBaseInfo(decoder, &baseInfo));

        // Create a unique file name for writing the crash dump data to a file.
        // Note: due to an Nsight Aftermath bug (will be fixed in an upcoming
        // driver release) we may see redundant crash dumps. As a workaround,
        // attach a unique count to each generated file name.
        static int count = 0;
        const std::string baseFileName =
            std::string("Aftermath")
            + "-"
            + std::to_string(baseInfo.pid)
            + "-"
            + std::to_string(++count);

        // Write the crash dump data to a file using the .nv-gpudmp extension
        // registered with Nsight Graphics.
        const std::string crashDumpFileName = baseFileName + ".nv-gpudmp";
        std::ofstream dumpFile(crashDumpFileName, std::ios::out | std::ios::binary);
        if (dumpFile)
        {
            dumpFile.write((const char*)pGpuCrashDump, gpuCrashDumpSize);
            dumpFile.close();
        }

        // Decode the crash dump to a JSON string.
        // Step 1: Generate the JSON and get the size.
        uint32_t jsonSize = 0;
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GpuCrashDump_GenerateJSON(
            decoder,
            GFSDK_Aftermath_GpuCrashDumpDecoderFlags_ALL_INFO,
            GFSDK_Aftermath_GpuCrashDumpFormatterFlags_NONE,
            AftermathShaderDebugInfoLookupCallback,
            AftermathShaderLookupCallback,
            AftermathShaderSourceDebugInfoLookupCallback,
            nullptr,
            &jsonSize));
        // Step 2: Allocate a buffer and fetch the generated JSON.
        std::vector<char> json(jsonSize);
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GpuCrashDump_GetJSON(
            decoder,
            uint32_t(json.size()),
            json.data()));

        // Write the crash dump data as JSON to a file.
        const std::string jsonFileName = crashDumpFileName + ".json";
        std::ofstream jsonFile(jsonFileName, std::ios::out | std::ios::binary);
        if (jsonFile)
        {
            // Write the JSON to the file (excluding string termination)
            jsonFile.write(json.data(), json.size() - 1);
            jsonFile.close();
        }

        // Destroy the GPU crash dump decoder object.
        AFTERMATH_CHECK_ERROR(GFSDK_Aftermath_GpuCrashDump_DestroyDecoder(decoder));
	}


	void InitializeAftermath()
	{
		GFSDK_Aftermath_EnableGpuCrashDumps(GFSDK_Aftermath_Version_API, GFSDK_Aftermath_GpuCrashDumpWatchedApiFlags_DX, GFSDK_Aftermath_GpuCrashDumpFeatureFlags_Default, AftermathCrashDumpCallback, AftermathShaderDebugInfoCallback, nullptr, nullptr,nullptr);
	}
	void DeinitAftermath()
	{
		GFSDK_Aftermath_DisableGpuCrashDumps();
	}
}
#else

namespace RGL {
    // stub these
    void InitializeAftermath()
    {
       
    }
    void DeinitAftermath()
    {
    }
}
#endif